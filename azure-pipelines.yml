# Docker
# Build and push an image to Azure Container Registry
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker

trigger:
- master

resources:
- repo: self

variables:
  # Set to the name or ID of your Azure DevOps ARM (Azure Resource Manager) service connection.
  # Recommended: define a pipeline variable named AZURE_SERVICE_CONNECTION in Azure DevOps UI and set it to your ARM connection.
  # IMPORTANT: Do NOT use a Docker Registry service connection here. It must be of type AzureRM.
  azureSubscription: 'Azure subscription Giter (79391428-3302-4885-804c-b1ee4fe7ba36)'
  acrName: 'giterappregistry'
  webAppName: 'web-calls'
  resourceGroup: 'GiterApps'
  # Container registry service connection established during pipeline creation
  dockerRegistryServiceConnection: '4a6af8e9-2ad7-403c-95c8-19e402b29025'
  imageRepository: 'webcall'
  containerRegistry: 'giterappregistry.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/backend/Dockerfile'
  tag: '$(Build.BuildId)'
  imageTag: '$(Build.BuildId)'
  acrLoginServer: '$(acrName).azurecr.io'
  backendImageName: 'web-call-backend'
  frontendImageName: 'web-call-frontend'
  turnImageName: 'web-call-turn'

  # Agent VM image name
  vmImageName: 'ubuntu-latest'

stages:
  - stage: Build
    displayName: Build and Push Images to ACR
    jobs:
      - job: BuildPush
        displayName: ACR Build
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: 'Build backend image in ACR'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az acr show -n "$(acrName)" -o none
                echo "Building backend image $(backendImageName):$(imageTag) in ACR $(acrName)"
                az acr build \
                  --registry "$(acrName)" \
                  --image "$(backendImageName):$(imageTag)" \
                  --file backend/Dockerfile \
                  .

          - task: AzureCLI@2
            displayName: 'Build frontend image in ACR'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az acr show -n "$(acrName)" -o none
                echo "Building frontend image $(frontendImageName):$(imageTag) in ACR $(acrName)"
                az acr build \
                  --registry "$(acrName)" \
                  --image "$(frontendImageName):$(imageTag)" \
                  --file frontend/Dockerfile \
                  --build-arg VITE_API_BASE="$(VITE_API_BASE)" \
                  --build-arg VITE_WS_BASE="$(VITE_WS_BASE)" \
                  --build-arg VITE_ICE_JSON="$(VITE_ICE_JSON)" \
                  --build-arg VITE_ICE_TRANSPORT_POLICY="$(VITE_ICE_TRANSPORT_POLICY)" \
                  .

          - task: AzureCLI@2
            displayName: 'Build TURN server image in ACR'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az acr show -n "$(acrName)" -o none
                echo "Building TURN server image $(turnImageName):$(imageTag) in ACR $(acrName)"
                # Create temporary Dockerfile for TURN server
                cat > Dockerfile.turn << 'EOF'
                FROM coturn/coturn:4.6.2
                USER root
                RUN apt-get update && apt-get install -y netcat-openbsd curl && rm -rf /var/lib/apt/lists/*
                USER turnserver
                EXPOSE 3478/tcp 3478/udp 50000-50100/udp
                HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
                  CMD nc -z localhost 3478 || exit 1
                EOF
                
                az acr build \
                  --registry "$(acrName)" \
                  --image "$(turnImageName):$(imageTag)" \
                  --file Dockerfile.turn \
                  .
                  
                # Cleanup
                rm -f Dockerfile.turn

          - script: |
              set -e
              COMPOSE_OUT="$(Build.ArtifactStagingDirectory)/docker-compose.azure.yaml"
              mkdir -p "$(Build.ArtifactStagingDirectory)"
              echo "Generating docker-compose at $COMPOSE_OUT"
              cat > "$COMPOSE_OUT" << 'EOF'
              version: '3.8'
              services:
                app:
                  image: ${ACR_LOGIN_SERVER}/${FRONTEND_IMAGE}:${IMAGE_TAG}
                  depends_on:
                    - backend
                  ports:
                    - '80:80'
                  expose:
                    - '80'
                backend:
                  image: ${ACR_LOGIN_SERVER}/${BACKEND_IMAGE}:${IMAGE_TAG}
                  environment:
                    PUBLIC_BASE_URL: ${PUBLIC_BASE_URL:-}
                  expose:
                    - '8000'
                turn:
                  image: ${ACR_LOGIN_SERVER}/${TURN_IMAGE}:${IMAGE_TAG}
                  command: >
                    turnserver
                    --listening-port=3478
                    --listening-ip=0.0.0.0
                    --user=user:secret
                    --realm=localhost
                    --min-port=50000
                    --max-port=50100
                    --fingerprint
                    --no-cli
                    --log-file=stdout
                    --verbose
                  expose:
                    - '3478'
                    - '50000-50100'
              EOF
              # Substitute variables for compose
              sed -i "s#\${ACR_LOGIN_SERVER}#$(acrLoginServer)#g" "$COMPOSE_OUT"
              sed -i "s#\${BACKEND_IMAGE}#$(backendImageName)#g" "$COMPOSE_OUT"
              sed -i "s#\${FRONTEND_IMAGE}#$(frontendImageName)#g" "$COMPOSE_OUT"
              sed -i "s#\${TURN_IMAGE}#$(turnImageName)#g" "$COMPOSE_OUT"
              sed -i "s#\${IMAGE_TAG}#$(imageTag)#g" "$COMPOSE_OUT"
            displayName: 'Generate docker-compose.azure.yaml'

          - publish: '$(Build.ArtifactStagingDirectory)'
            artifact: drop
            displayName: 'Publish artifacts'

  - stage: Deploy
    displayName: Deploy to Azure Web App (Multi-container)
    dependsOn: Build
    jobs:
      - deployment: DeployToWebApp
        environment: 'prod'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: drop
                - task: AzureWebAppContainer@1
                  displayName: 'Deploy compose to Azure Web App'
                  inputs:
                    azureSubscription: '$(azureSubscription)'
                    appName: '$(webAppName)'
                    resourceGroupName: '$(resourceGroup)'
                    multicontainerConfigFile: '$(Pipeline.Workspace)/drop/docker-compose.azure.yaml'
                    # Optionally set app settings (e.g., WEBSITES_PORT) if needed for your frontend port
                    appSettings: -DOCKER_REGISTRY_SERVER_URL https://$(acrLoginServer) -WEBSITES_ENABLE_APP_SERVICE_STORAGE true -WEBSITES_PORT 80

